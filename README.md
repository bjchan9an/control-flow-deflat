# control-flow-deflat
recover control-flow-flat obfuscation with supergraph in angrmanagement

# Use CFG like IDA-Pro-style in Angr
The CFG generated by ``proj.analyses.CFGFast()`` or ``proj.analyses.CFGEmulated()`` in Angr is different with the style in IDA Pro, for example, call instruction will split the basic blocks in Angr.

To solve this problem, ``barf`` and ``angr-management`` is useful. 
## 1. BARF
The script to recover "control-flow-flat" obfuscated cfg uses the binary analysis frame ``barf``:

```python
from barf import BARF

barf = BARF(filename)
cfg = barf.recover_cfg(ea_start = target_func)
blocks = cfg.basic_blocks
prologue = start
main_dispatcher = cfg.find_basic_block(prologue).direct_branch
```
For each block, ``block.instrs`` is provided to get a generator of instructions of a block, and ``ins.asm_instr.mnemonic`` return the str of OpCode.

## 2. AngrManagement
Generate CFG in IDA Pro style as follows
```python
import angrmanagement.utils.graph as gh

cfg = proj.analyses.CFGFast(normalize = True)   #proj = Angr.Project(filename)
target_func = cfg.functions.get(target_func_addr)
supergraph = gh.to_supergraph(target_func.tansition_graph)

for node in supergraph.nodes():
    if supergraph.in_degree(node) == 0:
        prologue_node = node
    if supergraph.out_degree(node) == 0:
        ret_node = node
main_dispatcher_node = list(supergraph.successors(prologue_node))[0]
for node in supergraph.predecessors(main_dispatcher_node):
        if node.addr != prologue_node.addr:
            pre_dispatcher_node = node
            break
```
Attention the parameter ``normalize`` of ``proj.analyses.CFGFast()`` is essential, or may cause overlapping blocks.

In this issue, ``CFGEmulated()`` don't mean more accurattion but extra problems.

#### 2.1 Supergraph API
+ ``supergraph``:
  ```python
  cfg = proj.analyses.CFGFast(normalize=True)
  target_func = cfg.functions.get(target_func_addr)
  supergraph = gh.to_supergraph(target_func.tansition_graph)
  ``` 
+ ``supergraph.nodes()`` : return generator of the nodes of CFG

+ ``supergraph.in_degree(node)``

+ ``supergraph.out_degree(node)``

+ ``supergraph.successors(node)`` : return generator of node succs

+ ``supergraph.predecessors(node)`` : return generator of node preds

+ ``node.addr``

+ ``supergraph.has_edge(node1, node2)``

#### 2.2 Angr Block

+ ``proj.factory.block(node.addr, size=node.size)`` : return basic block of node

+ ``block.capstone.insns`` : return list of instructions

+ ``ins.insn.mnemonic`` : return str of OpCode

+ ``ins.insn.address`` : return address of instruction



